# Service Worker Setup with Workbox

## Overview

Workbox is Google's library for building service workers. It provides pre-built caching strategies and handles the complex parts of service worker lifecycle.

## Caching Strategies

| Strategy | Description | Use For |
|----------|-------------|---------|
| **CacheFirst** | Cache → Network fallback | Static assets, fonts, images |
| **NetworkFirst** | Network → Cache fallback | API calls, dynamic content |
| **StaleWhileRevalidate** | Cache immediately, update in background | Semi-dynamic content |
| **NetworkOnly** | Network only, no caching | Real-time data, auth |
| **CacheOnly** | Cache only, no network | Precached app shell |

## Complete Service Worker Template

```typescript
// sw.ts or custom-service-worker.ts
import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { registerRoute, NavigationRoute, Route } from 'workbox-routing';
import {
  CacheFirst,
  NetworkFirst,
  StaleWhileRevalidate,
} from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';
import { BackgroundSyncPlugin } from 'workbox-background-sync';

declare const self: ServiceWorkerGlobalScope & typeof globalThis;

// ===========================================
// PRECACHING (App Shell)
// ===========================================

// Precache all assets generated by the build tool
// __WB_MANIFEST is replaced by the build tool with the list of URLs to precache
precacheAndRoute(self.__WB_MANIFEST);

// Clean up old caches from previous versions
cleanupOutdatedCaches();

// ===========================================
// STATIC ASSETS (CacheFirst)
// ===========================================

// Google Fonts - cache for 1 year
registerRoute(
  ({ url }) =>
    url.origin === 'https://fonts.googleapis.com' ||
    url.origin === 'https://fonts.gstatic.com',
  new CacheFirst({
    cacheName: 'google-fonts',
    plugins: [
      new CacheableResponsePlugin({ statuses: [0, 200] }),
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
      }),
    ],
  })
);

// Images - cache for 30 days
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images',
    plugins: [
      new CacheableResponsePlugin({ statuses: [0, 200] }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
        purgeOnQuotaError: true, // Delete if storage is low
      }),
    ],
  })
);

// Static assets (JS, CSS) - cache first, update in background
registerRoute(
  ({ request }) =>
    request.destination === 'script' ||
    request.destination === 'style',
  new StaleWhileRevalidate({
    cacheName: 'static-resources',
    plugins: [
      new CacheableResponsePlugin({ statuses: [0, 200] }),
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60 * 24 * 7, // 1 week
      }),
    ],
  })
);

// ===========================================
// API CALLS (NetworkFirst)
// ===========================================

// GET API requests - network first with cache fallback
registerRoute(
  ({ url, request }) =>
    url.pathname.startsWith('/api/') && request.method === 'GET',
  new NetworkFirst({
    cacheName: 'api-cache',
    networkTimeoutSeconds: 10, // Fallback to cache after 10s
    plugins: [
      new CacheableResponsePlugin({ statuses: [0, 200] }),
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 60 * 60 * 24, // 1 day
      }),
    ],
  })
);

// ===========================================
// BACKGROUND SYNC (Offline Mutations)
// ===========================================

// Queue for failed POST/PUT/DELETE requests
const bgSyncPlugin = new BackgroundSyncPlugin('api-mutation-queue', {
  maxRetentionTime: 24 * 60, // Retry for up to 24 hours
  onSync: async ({ queue }) => {
    let entry;
    while ((entry = await queue.shiftRequest())) {
      try {
        await fetch(entry.request);
        console.log('Background sync successful:', entry.request.url);
      } catch (error) {
        console.error('Background sync failed:', error);
        await queue.unshiftRequest(entry);
        throw error; // Re-throw to trigger retry
      }
    }
  },
});

// Register route for mutation requests
registerRoute(
  ({ url, request }) =>
    url.pathname.startsWith('/api/') &&
    ['POST', 'PUT', 'DELETE', 'PATCH'].includes(request.method),
  new NetworkFirst({
    cacheName: 'api-mutations',
    plugins: [bgSyncPlugin],
  }),
  'POST' // Method matching
);

// Also register for PUT, DELETE, PATCH
['PUT', 'DELETE', 'PATCH'].forEach((method) => {
  registerRoute(
    ({ url, request }) =>
      url.pathname.startsWith('/api/') && request.method === method,
    new NetworkFirst({
      cacheName: 'api-mutations',
      plugins: [bgSyncPlugin],
    }),
    method
  );
});

// ===========================================
// OFFLINE FALLBACK
// ===========================================

const OFFLINE_PAGE = '/offline';
const OFFLINE_IMAGE = '/images/offline.svg';

// Cache offline assets during install
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open('offline-fallback').then((cache) => {
      return cache.addAll([OFFLINE_PAGE, OFFLINE_IMAGE]);
    })
  );
});

// Serve offline page for failed navigation requests
registerRoute(
  new NavigationRoute(
    async ({ event }) => {
      try {
        // Try to fetch from network
        return await fetch(event.request);
      } catch (error) {
        // Return offline page
        const cache = await caches.open('offline-fallback');
        return (await cache.match(OFFLINE_PAGE)) as Response;
      }
    },
    {
      // Don't handle API routes as navigation
      denylist: [/\/api\//],
    }
  )
);

// Serve offline image for failed image requests
registerRoute(
  ({ request }) => request.destination === 'image',
  async ({ event }) => {
    try {
      // Try CacheFirst strategy first
      const cacheFirst = new CacheFirst({
        cacheName: 'images',
        plugins: [
          new CacheableResponsePlugin({ statuses: [0, 200] }),
          new ExpirationPlugin({ maxEntries: 100 }),
        ],
      });
      return await cacheFirst.handle({ event, request: event.request });
    } catch (error) {
      // Return offline placeholder image
      const cache = await caches.open('offline-fallback');
      return (await cache.match(OFFLINE_IMAGE)) as Response;
    }
  }
);

// ===========================================
// SERVICE WORKER LIFECYCLE
// ===========================================

// Skip waiting when asked by the client
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// Claim clients immediately after activation
self.addEventListener('activate', (event) => {
  event.waitUntil(self.clients.claim());
});

// ===========================================
// PUSH NOTIFICATIONS (Optional)
// ===========================================

self.addEventListener('push', (event) => {
  if (!event.data) return;

  const data = event.data.json();

  event.waitUntil(
    self.registration.showNotification(data.title, {
      body: data.body,
      icon: '/icons/icon-192x192.png',
      badge: '/icons/badge-72x72.png',
      tag: data.tag || 'default',
      data: data.url,
      actions: data.actions || [],
    })
  );
});

self.addEventListener('notificationclick', (event) => {
  event.notification.close();

  const url = event.notification.data || '/';

  event.waitUntil(
    self.clients.matchAll({ type: 'window' }).then((clients) => {
      // Focus existing window if open
      for (const client of clients) {
        if (client.url === url && 'focus' in client) {
          return client.focus();
        }
      }
      // Open new window
      return self.clients.openWindow(url);
    })
  );
});
```

## Framework-Specific Setup

### Quasar (InjectManifest)

```typescript
// quasar.config.ts
pwa: {
  workboxMode: 'InjectManifest',
  swFilename: 'sw.js',
  manifestFilename: 'manifest.json',
  injectPwaMetaTags: true,
}
```

Place your service worker at `src-pwa/custom-service-worker.ts`.

### Vite (vite-plugin-pwa)

```typescript
// vite.config.ts
import { VitePWA } from 'vite-plugin-pwa';

export default defineConfig({
  plugins: [
    VitePWA({
      strategies: 'injectManifest',
      srcDir: 'src',
      filename: 'sw.ts',
      registerType: 'prompt',
      injectManifest: {
        globPatterns: ['**/*.{js,css,html,ico,png,svg,woff2}'],
      },
    }),
  ],
});
```

### Next.js (next-pwa)

```typescript
// next.config.ts
import withPWA from 'next-pwa';

export default withPWA({
  dest: 'public',
  customWorkerDir: 'src/sw',
  disable: process.env.NODE_ENV === 'development',
});
```

## Service Worker Registration

```typescript
// register-sw.ts
export function registerServiceWorker() {
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', async () => {
      try {
        const registration = await navigator.serviceWorker.register('/sw.js');
        console.log('SW registered:', registration.scope);

        // Check for updates periodically
        setInterval(() => {
          registration.update();
        }, 60 * 60 * 1000); // Every hour

        // Handle updates
        registration.addEventListener('updatefound', () => {
          const newWorker = registration.installing;
          if (!newWorker) return;

          newWorker.addEventListener('statechange', () => {
            if (newWorker.state === 'installed') {
              if (navigator.serviceWorker.controller) {
                // New version available
                dispatchEvent(new CustomEvent('sw-update'));
              } else {
                // First install
                console.log('Content cached for offline use');
              }
            }
          });
        });
      } catch (error) {
        console.error('SW registration failed:', error);
      }
    });

    // Reload on controller change
    let refreshing = false;
    navigator.serviceWorker.addEventListener('controllerchange', () => {
      if (!refreshing) {
        refreshing = true;
        window.location.reload();
      }
    });
  }
}
```

## Cache Management Utilities

```typescript
// cache-utils.ts

// Get all cache names
export async function getCacheNames(): Promise<string[]> {
  return caches.keys();
}

// Get cache size
export async function getCacheSize(cacheName: string): Promise<number> {
  const cache = await caches.open(cacheName);
  const keys = await cache.keys();
  let size = 0;

  for (const request of keys) {
    const response = await cache.match(request);
    if (response) {
      const blob = await response.blob();
      size += blob.size;
    }
  }

  return size;
}

// Clear specific cache
export async function clearCache(cacheName: string): Promise<boolean> {
  return caches.delete(cacheName);
}

// Clear all caches
export async function clearAllCaches(): Promise<void> {
  const names = await caches.keys();
  await Promise.all(names.map((name) => caches.delete(name)));
}

// Precache specific URLs manually
export async function precacheUrls(
  cacheName: string,
  urls: string[]
): Promise<void> {
  const cache = await caches.open(cacheName);
  await cache.addAll(urls);
}
```

## Background Sync Queue Monitoring

```typescript
// sync-queue-monitor.ts
import { Queue } from 'workbox-background-sync';

// Get pending requests in queue
export async function getPendingRequests(
  queueName: string
): Promise<Request[]> {
  const queue = new Queue(queueName);
  const entries = await queue.getAll();
  return entries.map((entry) => entry.request);
}

// Get pending count
export async function getPendingCount(queueName: string): Promise<number> {
  const queue = new Queue(queueName);
  const entries = await queue.getAll();
  return entries.length;
}

// Clear queue (use with caution)
export async function clearQueue(queueName: string): Promise<void> {
  const db = await openDB('workbox-background-sync', 3);
  const tx = db.transaction('requests', 'readwrite');
  const store = tx.objectStore('requests');
  const index = store.index('queueName');

  let cursor = await index.openCursor(queueName);
  while (cursor) {
    await cursor.delete();
    cursor = await cursor.continue();
  }
}
```

## Testing Service Workers

### Chrome DevTools
1. Open DevTools → Application → Service Workers
2. Check "Update on reload" during development
3. Use "Offline" checkbox to test offline mode
4. Click "Update" to manually trigger update check

### Workbox Window

```typescript
// Using workbox-window for better UX
import { Workbox } from 'workbox-window';

if ('serviceWorker' in navigator) {
  const wb = new Workbox('/sw.js');

  // Show update notification
  wb.addEventListener('waiting', () => {
    // Show update UI
    if (confirm('New version available! Reload?')) {
      wb.messageSkipWaiting();
    }
  });

  // Reload on controller change
  wb.addEventListener('controlling', () => {
    window.location.reload();
  });

  wb.register();
}
```

## Common Issues

| Issue | Solution |
|-------|----------|
| SW not updating | Check cache headers, use `skipWaiting()` |
| Stale content | Use `StaleWhileRevalidate` or versioned URLs |
| API cache issues | Use `NetworkFirst` with reasonable timeout |
| Offline not working | Ensure `NavigationRoute` is set up |
| CORS errors | Use `CacheableResponsePlugin({ statuses: [0, 200] })` |
| Too much cached | Set `maxEntries` and `maxAgeSeconds` |
